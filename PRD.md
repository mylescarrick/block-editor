# Product Requirements Document: Unified Block Editor

## Executive Summary

A Notion-style block-based visual editor that provides a unified schema system enabling both manual editing and AI-assisted content generation. The architecture ensures that regardless of how content is created—manually by users or generated by AI—it conforms to the same type-safe schema, making all content fully editable and interoperable.

---

## Problem Statement

Modern document editors face a fundamental tension: users want the flexibility of AI-assisted content generation alongside traditional manual editing, but these two paradigms typically operate with incompatible data structures. AI-generated content often arrives as opaque blobs that can't be meaningfully edited, while manually-created content lacks the structured format needed for AI manipulation.

### Key Challenges

1. **Schema Divergence** — AI generation tools and WYSIWYG editors typically use different internal representations, creating friction when users want to edit AI-generated content or have AI modify manually-created content.

2. **Type Safety Erosion** — Without a unified schema, content can drift into invalid states, particularly when moving between AI and manual editing modes.

3. **Guardrail Requirements** — AI generation needs constraints to produce predictable, safe output, but those constraints must align with what the editor can actually render and edit.

4. **Layout Complexity** — Block editors need to support nested structures (columns, containers) while maintaining a flat-enough structure for efficient operations and AI comprehension.

---

## Goals & Success Criteria

### Primary Goals

| Goal | Success Metric |
|------|----------------|
| Unified content model | 100% of AI-generated content is immediately editable |
| Type safety | Zero runtime type errors from block operations |
| AI guardrails | AI can only produce valid, renderable blocks |
| Layout flexibility | Support for multi-column layouts with nested content |

### Non-Goals

- Real-time collaboration (future iteration)
- Mobile-first design (desktop-focused initially)
- Offline-first architecture (online assumed)
- Plugin marketplace (internal extensibility only)

---

## User Personas

### Content Creator (Primary)
Writers, marketers, and knowledge workers who create documents daily. They want speed and flexibility—sometimes typing manually, sometimes asking AI for help, and always expecting seamless transitions between modes.

### Technical Writer (Secondary)
Documentation authors who need precise control over structure (headings, code blocks, callouts) and appreciate keyboard-driven workflows. They value predictability over magic.

### Team Lead (Tertiary)
Reviews and edits documents created by others. Needs confidence that content structure is consistent regardless of who (or what) created it.

---

## Core Concepts

### The Unified Schema Principle

The central architectural decision is that **one schema governs all content**. This schema is:

1. **Defined in Zod** — Provides runtime validation and TypeScript inference
2. **Used by the editor** — All block operations validate against it
3. **Used by AI generation** — Constrains what AI can produce
4. **Serialisable** — Clean JSON representation for persistence

```typescript
// Single source of truth for block structure
const BlockSchema = z.discriminatedUnion('type', [
  ParagraphBlockSchema,
  HeadingBlockSchema,
  ImageBlockSchema,
  ColumnsBlockSchema,
  // ... all block types
]);
```

### Block Identity Model

Every block has a unique `id` that remains stable across edits. This enables:

- Efficient updates (modify by ID, not position)
- Drag-and-drop without content duplication
- Undo/redo with block-level granularity
- Column layouts referencing child blocks by ID

### Document Structure

The document uses a **normalised** structure—blocks stored in a flat map, with ordering maintained separately:

```typescript
interface BlockDocument {
  blocks: Record<string, Block>;  // All blocks by ID
  rootBlockIds: string[];         // Top-level ordering
}
```

This approach (similar to Redux normalisation patterns) enables O(1) block lookups while maintaining explicit ordering for root-level blocks. Column blocks reference their children by ID, creating a directed acyclic graph.

---

## Block Type Specifications

### Text Blocks

| Type | Purpose | Key Properties |
|------|---------|----------------|
| `paragraph` | Body text | `content` (HTML), `align` |
| `heading` | Section headers | `content`, `level` (h1-h3), `align` |
| `quote` | Blockquotes | `content`, `attribution` |

Text content is stored as HTML strings, produced by TipTap's serialisation. This preserves inline formatting (bold, italic, links, highlights) while remaining human-readable in the JSON.

### Media Blocks

| Type | Purpose | Key Properties |
|------|---------|----------------|
| `image` | Images with captions | `src`, `alt`, `caption`, `width` |
| `code` | Syntax-highlighted code | `code`, `language` |
| `divider` | Visual separation | `style` (solid/dashed/dotted) |

### Semantic Blocks

| Type | Purpose | Key Properties |
|------|---------|----------------|
| `callout` | Highlighted information | `content`, `variant`, `emoji` |

Callouts use a `variant` enum (`info`, `warning`, `success`, `error`) rather than arbitrary colours, ensuring semantic meaning and consistent styling.

### Layout Blocks

| Type | Purpose | Key Properties |
|------|---------|----------------|
| `columns` | Multi-column layouts | `layout`, `columns` (child IDs) |

The `columns` block is the only block type that contains references to other blocks. Its `columns` property is an array of arrays—each inner array contains the IDs of blocks in that column.

```typescript
// 2-column layout with one block per column
{
  type: 'columns',
  props: {
    layout: '1-1',
    columns: [['block-id-1'], ['block-id-2', 'block-id-3']]
  }
}
```

Layout ratios (`1-1`, `1-2`, `2-1`, `1-1-1`) are enums rather than arbitrary numbers, constraining the design space to tested, visually-balanced options.

---

## AI Integration Architecture

### Catalog-Based Generation

Inspired by json-render's approach, AI generation is constrained by providing a "catalog" of available blocks in the system prompt:

```typescript
function generateBlockCatalogPrompt(): string {
  return `
    Available block types:
    1. paragraph - Props: { content: string, align: "left"|"center"|"right" }
    2. heading - Props: { content: string, level: "h1"|"h2"|"h3" }
    ...
    Output valid JSON array of blocks.
  `;
}
```

This approach ensures:

- **Guardrails** — AI cannot invent block types or properties
- **Predictability** — Output structure is always parseable
- **Versioning** — Catalog changes are explicit and trackable

### Response Parsing

AI responses are parsed and validated before insertion:

1. Extract JSON from response (handling markdown code fences)
2. Assign unique IDs to any blocks missing them
3. Validate each block against the schema
4. Insert valid blocks into the document

Invalid blocks are logged and skipped rather than crashing the editor—graceful degradation over strict failure.

### Prompt Patterns

The AI stub demonstrates several generation patterns:

| Prompt Pattern | Generated Structure |
|----------------|---------------------|
| "Add an intro" | Heading + Paragraph |
| "Two-column layout" | Columns block + child paragraphs |
| "Feature list" | Multiple callout blocks |
| "Code example" | Heading + paragraph + code block |

These patterns show how AI can generate complex, nested structures that remain fully editable.

---

## Editing Experience

### Command Palette (Slash Menu)

Pressing `/` opens a searchable command palette offering:

1. **Block insertion** — All available block types
2. **AI generation** — Free-form prompt input
3. **Keyboard navigation** — Arrow keys, Enter to select, Escape to close

The palette appears inline at the cursor position (when in a text block) or centred (when triggered globally).

### Inline Formatting

Text selection reveals a bubble menu with formatting options:

- Bold, italic, underline, strikethrough
- Highlight (background colour)
- Link insertion
- Text alignment

Formatting is applied as TipTap marks, stored within the HTML content string.

### Block Operations

| Operation | Trigger | Behaviour |
|-----------|---------|-----------|
| Reorder | Drag handle | DnD Kit sortable, updates `rootBlockIds` |
| Duplicate | Menu → Duplicate | Deep copy with new ID |
| Delete | Menu → Delete | Removes from map and all references |
| Convert | (Future) | Change block type, preserve content where possible |

### Column Editing

Column blocks present a unique UX challenge—users need to:

1. Add content within specific columns
2. Change the column layout ratio
3. Move content between columns

The implementation shows column boundaries on hover, provides a layout selector, and allows dropping blocks into specific columns.

---

## State Management

### Document Store Hook

A custom `useDocumentStore` hook encapsulates all document operations:

```typescript
const {
  document,           // Current document state
  updateBlock,        // Modify a single block
  addBlock,           // Insert a new block
  removeBlock,        // Delete a block
  moveBlock,          // Reorder/reparent a block
  insertGeneratedBlocks,  // Batch insert from AI
} = useDocumentStore();
```

All mutations go through this hook, ensuring consistent state updates and auto-save triggering.

### Immutability Pattern

State updates use a clone-and-modify pattern:

1. Deep clone the document
2. Apply mutations to the clone
3. Update the timestamp
4. Replace state with new reference

This enables simple change detection, undo/redo implementation (future), and prevents accidental mutations.

### Auto-Save

Document changes trigger a debounced save (1 second delay). The save is:

- **Non-blocking** — UI remains responsive
- **Deduped** — Rapid changes coalesce into single save
- **Status-indicated** — UI shows "Saving..." / "Saved" states

---

## Technical Architecture

### Technology Choices

| Layer | Technology | Rationale |
|-------|------------|-----------|
| UI Framework | React 19 | Industry standard, hooks-based state |
| Rich Text | TipTap (ProseMirror) | Battle-tested, extensible, React bindings |
| Schema Validation | Zod | Runtime + static types, composable |
| Drag & Drop | DnD Kit | Accessible, performant, React-native |
| Styling | Tailwind CSS | Utility-first, no CSS-in-JS overhead |
| Build | Vite | Fast HMR, ESM-native, simple config |

### Why TipTap over Alternatives

- **vs Slate.js** — TipTap's extension system is more mature; Slate requires more low-level work
- **vs Lexical** — TipTap has larger ecosystem and shadcn/ui compatibility
- **vs Quill** — TipTap offers finer control and better TypeScript support

### Why Zod over Alternatives

- **vs io-ts** — Simpler API, better error messages
- **vs Yup** — Better TypeScript inference, discriminated unions
- **vs JSON Schema** — Colocated types, runtime validation, transforms

---

## Extensibility

### Adding New Block Types

1. **Define schema** — Add Zod schema in `types/blocks.ts`
2. **Add to union** — Include in `BlockSchema` discriminated union
3. **Create renderer** — Implement React component in `BlockRenderer.tsx`
4. **Add to palette** — Include in command palette items
5. **Update AI catalog** — Add to generation prompt

The process is intentionally explicit—each block type is a conscious addition to the system's capabilities.

### Custom Styling

The editor uses CSS variables and Tailwind utilities. Customisation points:

- **Theme colours** — `tailwind.config.js` extends the palette
- **Typography** — Font family variables in CSS
- **Block styles** — Each renderer accepts `className` overrides

### Persistence Adapters

The persistence layer is abstracted behind async functions:

```typescript
export async function saveDocument(doc: BlockDocument): Promise<BlockDocument>;
export async function loadDocument(id: string): Promise<BlockDocument | null>;
```

Implementations can target localStorage (demo), REST APIs, GraphQL, or real-time databases without changing the editor code.

---

## Future Considerations

### Real-Time Collaboration

The normalised document structure positions well for CRDT-based collaboration:

- Blocks map naturally to CRDT objects
- IDs enable conflict-free concurrent edits
- Ordering arrays can use fractional indexing

Yjs integration with TipTap is well-documented and would extend to the block layer.

### Version History

The immutable update pattern enables:

- Snapshot-based versioning (store full documents)
- Operation-based history (store mutations)
- Branching/merging workflows

### Block Transformations

Future iteration could support:

- Convert paragraph to heading (and vice versa)
- Convert bullet list to callouts
- Extract column content to root level
- Merge adjacent blocks of same type

### AI Enhancements

- **Streaming generation** — Render blocks as they arrive
- **Edit suggestions** — AI proposes changes inline
- **Content analysis** — Suggest structure improvements
- **Image generation** — AI creates images for image blocks

---

## Security Considerations

### Content Sanitisation

HTML content from TipTap is already sanitised, but additional considerations:

- **XSS prevention** — TipTap strips script tags by default
- **Link validation** — Could enforce HTTPS, blocklist domains
- **Image sources** — Could restrict to approved CDNs

### AI Safety

- **Prompt injection** — System prompt is server-side, not exposed
- **Output validation** — All AI output parsed against schema
- **Rate limiting** — (Production) limit AI generation requests

### Data Privacy

- **Local storage** — Demo only; production needs encrypted persistence
- **Image uploads** — Should go to authenticated storage, not object URLs
- **Audit logging** — Track who created/modified blocks

---

## Appendix: Design Decisions Log

| Decision | Alternatives Considered | Rationale |
|----------|------------------------|-----------|
| HTML for text content | Markdown, ProseMirror JSON | HTML preserves formatting, readable, TipTap-native |
| Flat block map + ordering array | Nested tree structure | O(1) lookups, simpler updates, CRDT-friendly |
| Column layouts as blocks | CSS grid on paragraphs | Explicit structure, AI-comprehensible, portable |
| Zod discriminated unions | Tagged unions, class hierarchy | Best TypeScript inference, runtime validation |
| Enum for layout ratios | Arbitrary percentages | Constrained design space, tested combinations |
| ID-based column children | Inline block storage | Enables same block in multiple contexts (future) |
| Debounced auto-save | Explicit save button | Modern UX expectation, reduces data loss |

---

## Conclusion

This block editor architecture demonstrates that AI-assisted content creation and traditional editing need not be separate concerns. By establishing a unified schema as the single source of truth, we enable a seamless experience where users can freely mix manual editing and AI generation, confident that all content is fully editable, type-safe, and structurally consistent.

The implementation prioritises:

- **Developer experience** — Type safety, clear extension points
- **User experience** — Familiar Notion-like interactions
- **AI compatibility** — Constrained generation, predictable output
- **Future-proofing** — Collaboration-ready architecture

The stubbed persistence and AI layers demonstrate the integration points while keeping the core editor implementation focused and portable.
