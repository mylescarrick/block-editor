# Block Editor PoC

A Notion-style block-based visual editor with a unified schema system that enables both manual editing and AI-assisted content generation. Built to demonstrate how structured content can flow seamlessly between human authoring and AI generation.

## What This PoC Demonstrates

This proof-of-concept solves a fundamental tension in modern document editors: **AI-generated content and manually-created content typically use incompatible data structures**. AI output often arrives as opaque blobs that can't be meaningfully edited, while WYSIWYG content lacks the structure needed for AI manipulation.

Our approach: **one Zod schema governs all content**. Whether a block is typed by hand or generated by AI, it conforms to the same type-safe schema—making everything fully editable and interoperable.

### Key Features

- **Unified Schema** — Zod schemas define block types, used by both editor and AI generation
- **Visual Editing** — Notion-like block editor with rich text, drag-and-drop, slash commands
- **AI Generation** — Stubbed AI that generates valid, editable blocks from natural language
- **Structure Preview** — Tab to view the underlying JSON structure in real-time
- **Auto-Save** — Debounced persistence with visual status indicators

---

## Architecture

### Document Structure (Normalised)

```typescript
interface BlockDocument {
  id: string;
  title: string;
  blocks: Record<string, Block>;  // Flat map: all blocks by ID
  rootBlockIds: string[];         // Array: defines top-level ordering
  createdAt: string;
  updatedAt: string;
}
```

**Why normalised?**
- **O(1) lookups** — Access any block by ID instantly
- **Clean updates** — Modify blocks without traversing trees
- **AI-friendly** — Flat structures are easier to generate and validate
- **CRDT-ready** — Positions well for future real-time collaboration

The `blocks` map stores content; `rootBlockIds` stores order. Column layouts reference child blocks by ID, creating a directed acyclic graph.

### Block Types

| Type | Purpose | Key Properties |
|------|---------|----------------|
| `paragraph` | Body text | `content` (HTML), `align` |
| `heading` | Section headers (h1-h3) | `content`, `level`, `align` |
| `quote` | Blockquotes | `content`, `attribution` |
| `image` | Images with captions | `src`, `alt`, `caption`, `width` |
| `code` | Syntax-highlighted code | `code`, `language` |
| `divider` | Visual separation | `style` (solid/dashed/dotted) |
| `callout` | Highlighted info boxes | `content`, `variant`, `emoji` |
| `columns` | Multi-column layouts | `layout`, `columns` (child IDs) |

### AI Integration

Inspired by [json-render](https://json-render.dev/), AI generation is constrained via a **block catalog** in the system prompt. The AI receives available block types and their props, outputs JSON, which is validated against the Zod schema before insertion.

---

## Project Structure

```
src/
├── components/
│   ├── block-editor.tsx      # Main editor with tabs (Editor/Structure)
│   ├── block-renderer.tsx    # Individual block renderers
│   ├── command-palette.tsx   # Slash command menu + AI prompt
│   ├── json-preview.tsx      # Structure tab: JSON view + validation
│   ├── rich-text-editor.tsx  # TipTap-based text editing
│   └── ui/                   # shadcn/ui components
├── hooks/
│   └── use-document-store.ts # Document state, CRUD operations, auto-save
├── lib/
│   ├── ai.ts                 # AI generation (stub with mock responses)
│   ├── persistence.ts        # IndexedDB persistence (stub)
│   └── utils.ts              # Block creation, cloning, layout helpers
└── types/
    └── blocks.ts             # Zod schemas and TypeScript types
```

### Key Components

| Component | Responsibility |
|-----------|---------------|
| `useDocumentStore` | All document mutations, auto-save scheduling, state management |
| `BlockRenderer` | Switch over block types, render appropriate component |
| `CommandPalette` | Slash menu for block insertion and AI prompts |
| `RichTextEditor` | TipTap wrapper with bubble menu for formatting |
| `JsonPreview` | Real-time JSON view with schema validation badge |

---

## Usage

```bash
bun install && bun run dev
```

| Action | Trigger |
|--------|---------|
| Add block | `/` or "Add block" button |
| Edit text | Click block |
| Format | Select text → bubble menu |
| Reorder | Drag grip handle |
| Duplicate/Delete | Hover → actions menu |
| View JSON | "Structure" tab |

**AI prompts (stubbed):** `"Add an intro"`, `"Two-column layout"`, `"Code example"`, `"Feature list"`

---

## Integration Guide

### Adding to Your Monorepo

1. **Copy `src/`** into your app
2. **Install dependencies**:
   ```bash
   bun add @tiptap/react @tiptap/starter-kit @tiptap/pm \
     @tiptap/extension-placeholder @tiptap/extension-underline @tiptap/extension-link \
     @tiptap/extension-highlight @tiptap/extension-bubble-menu @tiptap/extension-image \
     @tiptap/extension-text-align @tiptap/extension-text-style @tiptap/extension-color \
     @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities \
     @radix-ui/react-tabs class-variance-authority clsx tailwind-merge lucide-react \
     zod uuid
   ```
3. **Import**:
   ```tsx
   import { BlockEditor } from '@/components/block-editor';
   // Use: <BlockEditor documentId="doc-123" />
   ```

### Replacing Stubs

**Persistence** — Swap `src/lib/persistence.ts`:

```typescript
export async function saveDocument(doc: BlockDocument): Promise<BlockDocument> {
  const res = await fetch(`/api/documents/${doc.id}`, { method: 'PUT', body: JSON.stringify(doc) });
  return res.json();
}
export async function loadDocument(id: string): Promise<BlockDocument | null> {
  const res = await fetch(`/api/documents/${id}`);
  return res.ok ? res.json() : null;
}
```

**AI** — Swap `src/lib/ai.ts`:

```typescript
export async function generateBlocksFromPrompt(prompt: string): Promise<Block[]> {
  const res = await fetch('/api/generate', {
    method: 'POST',
    body: JSON.stringify({ prompt, systemPrompt: generateBlockCatalogPrompt() }),
  });
  return parseAIResponse((await res.json()).content);
}
```

### Adding a New Block Type

1. **Define schema** in `src/types/blocks.ts`
2. **Add to union** in `BlockSchema`
3. **Create renderer** in `block-renderer.tsx`
4. **Add to palette** in `command-palette.tsx`
5. **Update AI catalog** in `ai.ts`

---

## Tech Stack

| Layer | Choice |
|-------|--------|
| UI | React 19 |
| Rich Text | TipTap (ProseMirror) |
| Schema | Zod |
| DnD | DnD Kit |
| Styling | Tailwind CSS 4 + shadcn/ui |
| Build | Vite |

---

## Future Considerations

- **Real-time collaboration** — Yjs integration (TipTap supports; block layer needs CRDT)
- **Streaming AI** — JSONL patches for progressive rendering
- **Version history** — Immutable updates enable snapshots
- **Block transformations** — Convert between types

---

## Design Decisions

| Decision | Rationale |
|----------|-----------|
| HTML for text content | Preserves formatting, human-readable, TipTap-native |
| Flat blocks + ordering array | O(1) lookups, simpler updates, CRDT-friendly |
| Zod discriminated unions | Best TypeScript inference, runtime validation |
| Enum layout ratios | Constrained design space, tested combinations |
| Debounced auto-save | Modern UX expectation, reduces data loss |
| ID-based children | Enables consistent references, future deduplication |

---

## License

MIT
